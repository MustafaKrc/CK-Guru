services:
  #################
  # Backend API
  #################
  backend:
    build:
      context: .
      dockerfile: backend/Dockerfile # Points to the updated Dockerfile
    container_name: ckguru_backend
    volumes:
      - ./backend/app:/app/app # Hot-reload for backend code
      - app_data:/app/persistent_data # Maps the named volume for storage
      # Mounts for alembic are still useful for development to see changes
      # without rebuilding the image every time.
      - ./backend/alembic.ini:/app/alembic.ini
      - ./backend/alembic:/app/alembic
      - ./shared:/app/shared # Shared directory hot-reload 
    ports:
      - "8000:8000"
    env_file:
      - .env
    environment:
      STORAGE_BASE_PATH: /app/persistent_data
    depends_on:
      db:
        condition: service_healthy # IMPORTANT: Wait for DB healthcheck
      broker:
        condition: service_started # Adjust condition as needed
      redis:
        condition: service_started
  #################
  # Celery Worker
  #################
  worker:
    build:
      context: .
      dockerfile: worker/Dockerfile
    container_name: ckguru_worker
    volumes:
      - ./worker/app:/app/app # Optional: hot-reload 
      - ./shared:/app/shared # Shared directory hot-reload 
      - app_data:/app/persistent_data
    env_file:
      - .env
    environment:
      STORAGE_BASE_PATH: /app/persistent_data
      # Ensure CUDA devices are visible (often handled by deploy key, but can be explicit)
      # NVIDIA_VISIBLE_DEVICES: all # Set this if needed
      NVIDIA_DRIVER_CAPABILITIES: compute,utility # Often needed
    depends_on:
      - broker
      - db
      - redis
    # <<< --- GPU Configuration --- >>>
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              # count: 1 # Request exactly one GPU
              count: all # Request all available GPUs
              capabilities: [gpu] # Request GPU capabilities

  #################
  # Frontend UI
  #################
  frontend:
    build:
      context: ./frontend # Context is the frontend directory
      dockerfile: Dockerfile
    container_name: ckguru_frontend
    ports:
      - "3000:80" # Map host port 3000 to Nginx container port 80
    depends_on:
      - backend # Usually depends on backend being available

  #################
  # Database
  #################
  db:
    image: postgres:15-alpine
    container_name: ckguru_db
    volumes:
      - postgres_data:/var/lib/postgresql/data # Persistent DB data
    env_file:
      - .env # For POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB
    ports:
      - "5432:5432" # Optional: Expose DB port to host for debugging
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 5s
      timeout: 10s
      retries: 5

  #################
  # Message Broker
  #################
  broker:
    image: rabbitmq:3.12-management-alpine
    container_name: ckguru_broker
    env_file:
      - .env # For RABBITMQ_DEFAULT_USER, RABBITMQ_DEFAULT_PASS
    ports:
      - "5672:5672"   # AMQP protocol port
      - "15672:15672" # Management UI port

  #################
  # Result Backend (Redis)
  #################
  redis:
    image: redis:7-alpine
    container_name: ckguru_redis
    # ports: # Optional: Expose port 6379 to host for debugging if needed
    #   - "6379:6379"
    volumes:
      - redis_data:/data # Persistent storage for Redis data
    # Add a basic healthcheck (optional but good practice)
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

#################
# Volumes
#################
volumes:
  postgres_data: # Stores PostgreSQL data
  app_data:      # Stores datasets, models, etc. (local storage via fsspec)
  redis_data:    # Stores Redis data (optional, but good for persistence)